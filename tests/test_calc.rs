use calc::exec;

#[test]

fn test_exec() {
    let shouldfail = ((-1 as i32) as usize) as f64;
    for tc in vec![
        ("-(1+1)", -2.),
        ("-(1.3+1.9)", -(1.3 + 1.9)),
        ("-5", -5.),
        ("4 - 9", -5.),
        ("(1+4*5)-5", ((1. + 4. * 5.) - 5.)),
        ("4/(4-1)*5", 4. / (4. - 1.) * 5.),
        ("4/5/6/7", 4. / 5. / 6. / 7.),
        ("2/2/3", 2. / 2. / 3.),
        ("3/3/4/5/6", 3. / 3. / 4. / 5. / 6.),
        ("(3-1)*5+1", (3. - 1.) * 5. + 1.),
        ("2^3^2", (2 as f64).powf((3 as f64).powf(2.))),
        ("2.3^3^2", (2.3 as f64).powf((3 as f64).powf(2.))),
        ("(2^3)^2", (2 as f64).powf(3.).powf(2.)),
        ("5^3/2", (5 as f64).powf(3.) / 2.),
        ("5.3^3/2.7", (5.3 as f64).powf(3.) / 2.7),
        ("5^3*2", (5 as f64).powf(3.) * 2.),
        ("2*5^3", 2. * (5 as f64).powf(3.)),
        ("5^3+2", (5 as f64).powf(3.0) + 2.0),
        ("5^3-2", (5 as f64).powf(3.) - 2.),
        ("5*3^2", (5. * (3 as f64).powf(2.))),
        ("5*(3^2)", 5. * (3 as f64).powf(2.)),
        ("3/(3/4/5)/6", 3. / (3. / 4. / 5.) / 6.),
        (
            "3/(3*3-2/4/5)^2/6",
            3. / ((3. * 3. - 2. / 4. / 5.) as f64).powf(2.) / 6.,
        ),
        (
            "1+3/(3*3-2/4/5)^2/6",
            1. + 3. / ((3. * 3. - 2. / 4. / 5.) as f64).powf(2.) / 6.,
        ),
        (
            "1+3/(3*3-2/4/5)^2 / 6 mod 4",
            1. + 3. / ((3. * 3. - 2. / 4. / 5.) as f64).powf(2.) / 6. % 4.,
        ),
        ("2+(4*3/2)", 2. + (4. * 3. / 2.)),
        ("2+4^3-6", 60.),
        ("2*4^3", 2. * (4 as f64).powf(3.0)),
        ("(((2)))", 2.),
        ("((((((((((3.5))))))))))", 3.5),
        ("( (((( (((  ((4.5) )))    )))) ))", 4.5),
        ("2^2", 4.),
        ("(2)^2", 4.),
        ("(2)^(2)", 4.),
        ("4 mod 5", 4. % 5.),
        ("(4 mod 5)", 4. % 5.),
        ("4 mod 5 * 2", (4. % 5.) * 2.),
        (
            "(4 mod 5 * 2) + (4 mod 5 / 2)",
            (4.0 % 5.0 * 2.0) + (4. % 5. / 2.),
        ),
        (
            "(4 mod 5 + 2) + (4 mod 5 - 2)",
            (4.0 % 5.0 + 2.0) + (4. % 5. - 2.),
        ),
        (
            "(4 + 17 mod 9) + (4 * 17 mod 9) + (4 / 17 mod 9)",
            (4. + 17. % 9.) + (4. * 17. % 9.) + (4. / 17. % 9.),
        ),
        (
            "4 + 17 mod 9 + 4 * 17 mod 9 + 4 / 17 mod 9",
            4. + 17. % 9. + 4. * 17. % 9. + 4. / 17. % 9.,
        ),
        ("32 / 3 mod 7", 32. / 3. % 7.),
        ("2 ^ 3 mod 7", (2 as f64).powf(3.) % 7.),
        ("7 mod 2^3", 7. % (2 as f64).powf(3.)),
        ("9 mod 10 mod 6", 9. % 10. % 6.),
        ("11 mod 12 mod 7 mod 3", 11. % 12. % 7. % 3.),
        // ("11 % 12 % 7 % 3", 11. % 12. % 7. % 3.),
        ("(((((10)))mod 5))", 10. % 5.),
        ("9mod 5", 9. % 5.), // TODO: maybe don't allow this
        ("12%", 12. / 100.),
        ("12% of 55", (12. / 100.) * 55.),
        (
            "(50 + 23)% of (100 + 1)",
            ((50. + 23.) / 100.) * (100. + 1.),
        ),
        ("23%of 55", (23. / 100.) * 55.),
        ("23%of 55 + 23", ((23. / 100.) * 55.) + 23.),
        ("3*23%of 55 + 23", 3.0 * ((23. / 100.) * 55.) + 23.),
        ("3*(23%of 55) + 23", 3.0 * ((23. / 100.) * 55.) + 23.),
        ("23 % of40", shouldfail),
        ("12% (of 30)", shouldfail),
        ("12% )of 30", shouldfail),
        ("%", shouldfail),
        ("()", shouldfail),
        ("3 / (23% of 55) / 23", 3. / ((23. / 100.) * 55.) / 23.),
        ("3 / 23% of 55 * 23", 3.0 / ((23. / 100.) * 55.) * 23.),
        ("3 / 23% of 55 / 23", 3.0 / ((23. / 100.) * 55.) / 23.),
    ] {
        let res = match exec(tc.0) {
            Ok(res) => res,
            Err(msg) => {
                if tc.1 == shouldfail {
                    continue;
                } else {
                    panic!(msg)
                }
            }
        };
        if res != tc.1 {
            panic!(format!("{} expected {}, got {}", tc.0, tc.1, res));
        }
        assert_eq!(res, tc.1);
    }
}
